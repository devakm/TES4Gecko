package TES4Gecko;

import java.io.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Properties;
import java.util.zip.DataFormatException;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

/**
 * The Plugin class represents the contents of a plugin file.  This can be a .esm file
 * or a .esp file.  The Master class differs from the Plugin class in that Plugin loads
 * all of the records into storage while the Master class reads records from disk as needed.
 */
public class Plugin extends SerializedElement {
    
    /** Plugin file */
    private File pluginFile;
    
    /** Plugin header */
    private PluginHeader pluginHeader;
    
    /** Plugin groups */
    private ArrayList<PluginGroup> groupList;
    
    /** Form information */
    private ArrayList<FormInfo> formList;
    
    /** Form ID map */
    private HashMap<Integer, FormInfo> formMap;
    
    /** Merged group list */
    private static final String[] initialGroupList = 
        {"GMST", "GLOB", "CLAS", "FACT", "HAIR", "EYES", "RACE", 
         "SOUN", "SKIL", "MGEF", "SCPT", "LTEX", "ENCH", "SPEL", 
         "BSGN", "ACTI", "APPA", "ARMO", "BOOK", "CLOT", "CONT", 
         "DOOR", "INGR", "LIGH", "MISC", "STAT", "GRAS", "TREE", 
         "FLOR", "FURN", "WEAP", "AMMO", "NPC_", "CREA", "LVLC", 
         "SLGM", "KEYM", "ALCH", "SBSP", "SGST", "LVLI", "WTHR", 
         "CLMT", "REGN", "CELL", "WRLD", "DIAL", "QUST", "IDLE", 
         "PACK", "CSTY", "LSCR", "LVSP", "ANIO", "WATR", "EFSH"};
    
    public static final int NoRegionAssignedToCell = 0xFFFF;

    /**
     * Create a new plugin
     *
     * @param       pluginFile      The plugin file
     */
    public Plugin(File pluginFile) {
        this.pluginFile = pluginFile;
        pluginHeader = new PluginHeader(pluginFile);
        groupList = new ArrayList<PluginGroup>(initialGroupList.length);
        formList = new ArrayList<FormInfo>(1000);
        formMap = new HashMap<Integer, FormInfo>(1000);
    }
    
    /**
     * Create a new plugin
     *
     * @param       pluginFile      The plugin file
     * @param       creator         The plugin creator
     * @param       summary         The plugin summary
     * @param       masterList      The plugin master list
     */
    public Plugin(File pluginFile, String creator, String summary, List<String> masterList) {
        this.pluginFile = pluginFile;
        pluginHeader = new PluginHeader(pluginFile);
        pluginHeader.setCreator(creator);
        pluginHeader.setSummary(summary);
        pluginHeader.setMasterList(masterList);
        groupList = new ArrayList<PluginGroup>(initialGroupList.length);
        formList = new ArrayList<FormInfo>(1000);
        formMap = new HashMap<Integer, FormInfo>(1000);
    }
    
    /**
     * Return the plugin name
     *
     * @return                      The plugin name
     */
    public String getName() {
        return pluginFile.getName();
    }
    
    /**
     * Return the plugin file
     *
     * @return                      The plugin file
     */
    public File getPluginFile() {
        return pluginFile;
    }
    
    /**
     * Sets the plugin file
     *
     * @param       file               The plugin file
     */
    public void setPluginFile(File file) {
        pluginFile = file;
    }
    
    /**
     * Return the plugin version
     *
     * @return                      The plugin version
     */
    public float getVersion() {
        return pluginHeader.getVersion();
    }
    
    /**
     * Set the plugin version
     *
     * @param       version         The plugin version
     */
    public void setVersion(float version) {
        pluginHeader.setVersion(version);
    }
    
    /**
     * Return the plugin creator
     *
     * @return                      The plugin creator
     */
    public String getCreator() {
        return pluginHeader.getCreator();
    }
    
    /**
     * Set the plugin creator
     *
     * @param       creator         The plugin creator
     */
    public void setCreator(String creator) {
        pluginHeader.setCreator(creator);
    }
    
    /**
     * Return the plugin summary
     *
     * @return                      The plugin summary
     */
    public String getSummary() {
        return pluginHeader.getSummary();
    }
    
    /**
     * Set the plugin summary
     *
     * @param       summary         The plugin summary
     */
    public void setSummary(String summary) {
        pluginHeader.setSummary(summary);
    }
    
    /**
     * Return the plugin record count
     *
     * @return                      The record count
     */
    public int getRecordCount() {
        return pluginHeader.getRecordCount();
    }
    
    /**
     * Check if this is a master file
     *
     * @return                      TRUE if this is a master file
     */
    public boolean isMaster() {
        return pluginHeader.isMaster();
    }
    
    /**
     * Set the file as a master or a plugin file
     *
     * @param       master          TRUE if this is a master file
     */
    public void setMaster(boolean master) {
        pluginHeader.setMaster(master);
    }
    
    /**
     * Return the plugin master list
     *
     * @return                      The master list
     */
    public List<String> getMasterList() {
        return pluginHeader.getMasterList();
    }
    
    /**
     * Set the plugin master list
     *
     * @param       masterList      The plugin master list
     */
    public void setMasterList(List<String> masterList) {
        pluginHeader.setMasterList(masterList);
    }
    
    /**
     * Reset the form list to empty.
     *
     */
    public void resetFormList() {
    	// Null out values first.
    	for (int i = 0; i < formList.size(); i++)
    	{
    		formList.set(i, null);
    	}
        formList = new ArrayList<FormInfo>(1000);
    }
    
    /**
     * Reset the form map to empty
     *
     */
    public void resetFormMap() {
    	formMap.clear();
        formMap = new HashMap<Integer, FormInfo>(1000);
    }
    
    /**
     * Repopulate the form list by resetting and then repopping.
     *
     */
    public void repopulateFormList()
    {
        formList = new ArrayList<FormInfo>(1000);
        List<PluginGroup> topGroups = this.getGroupList();
        for (PluginGroup topGroup : topGroups)
        {
        	topGroup.updateFormList(formList);
        }
    }
    
    /**
     * Reset the form map by resetting and then repopping.
     * Repop the form list first.
     *
     */
    public void repopulateFormMap()
    {
        formMap = new HashMap<Integer, FormInfo>(1000);
        for (FormInfo info : formList) {
            info.setPlugin(this);
            formMap.put(new Integer(info.getFormID()),  info);
        }

    }
    
    /**
     * Return the form list
     *
     * @return                      The form list
     */
    public List<FormInfo> getFormList() {
        return formList;
    }
    
    /**
     * Return the form map
     *
     * @return                      The form map
     */
    public Map<Integer, FormInfo> getFormMap() {
        return formMap;
    }
    
    /**
     * Return the group list
     *
     * @return                      The group list
     */
    public List<PluginGroup> getGroupList() {
        return groupList;
    }
     
    /**
     * Create the initial group list.  Any existing groups will be cleared.
     */
    public void createInitialGroups() {
        
        //
        // Clear any existing plugin groups
        //
        groupList.clear();
        formList.clear();
        formMap.clear();
        
        //
        // Create the initial top-level groups
        //
        for (int i=0; i<initialGroupList.length; i++)
            groupList.add(new PluginGroup(initialGroupList[i]));
    }
    
    /**
     * Create a new TOP group for the plugin if it doesn't exist yet
     *
     * @param       recordType          The group record type
     * @return                          The requested group
     * @exception   PluginException     Plugin error
     */
    public PluginGroup createTopGroup(String recordType) throws PluginException {
        PluginGroup group = null;
        boolean foundGroup = false;
        boolean createdGroup = false;
        int index, size;
        
        //
        // Locate the desired group
        //
        for (index=0; index<initialGroupList.length; index++) {
            if (initialGroupList[index].equals(recordType)) {
                foundGroup = true;
                break;
            }
        }
        
        if (!foundGroup)
            throw new PluginException("TOP group type "+recordType+" is not valid");
        
        //
        // Create the new group
        //
        size = groupList.size();
        for (int i=0; i<size; i++) {
            group = groupList.get(i);
            String groupRecordType = group.getGroupRecordType();
            for (int j=0; j<initialGroupList.length; j++) {
                if (initialGroupList[j].equals(groupRecordType)) {
                    if (j == index) {
                        createdGroup = true;
                    } else if (j > index) {
                        group = new PluginGroup(recordType);
                        groupList.add(i, group);
                        createdGroup = true;
                    }
                    
                    break;
                }
            }
            
            if (createdGroup)
                break;
        }
        
        if (!createdGroup) {
            group = new PluginGroup(recordType);
            groupList.add(group);
        }
        
        return group;
    }
    
    /**
     * Create the group hierarchy for a record or group obtained from another plugin.
     * The record or group must be a member of a group in the original plugin.  The
     * group hierarchy in the original plugin will be used if a record or group
     * does not exist in the current plugin.
     *
     * @param       record                  Record being added
     * @param       formAdjust              The form adjustment
     * @return                              The parent group for the record
     * @exception   DataFormatException     Error while expanding the record data
     * @exception   IOException             An I/O error occurred
     * @exception   PluginException         The record data is not valid
     */
    public PluginGroup createHierarchy(PluginRecord record, FormAdjust formAdjust)
                                            throws DataFormatException, IOException, PluginException {
        PluginGroup pluginGroup = null;
        PluginGroup parentGroup = (PluginGroup)record.getParent();
        if (parentGroup == null) {
            if (record instanceof PluginGroup)
                throw new PluginException(String.format("Type %d group does not have a parent",
                                                        ((PluginGroup)record).getGroupType()));
            else
                throw new PluginException(String.format("%s record %s (%08X) does not have a parent",
                                                        record.getRecordType(), record.getEditorID(), record.getFormID()));
        }

        int groupType = parentGroup.getGroupType();
        if (groupType == PluginGroup.TOP) {

            //
            // Locate the TOP group and create it if it doesn't already exist
            //
            pluginGroup = createTopGroup(parentGroup.getGroupRecordType());

        } else {

            boolean foundGroup = false;
            
            //
            // A CELL record can move to a different group hierarchy.  So we need to check if the 
            // CELL record already exists in the current plugin and use that hierarchy if it does.  
            // Similarly, cell children need to be moved if the CELL record already exists in a
            // different group hierarchy.
            //
            if (record instanceof PluginGroup) {
                PluginGroup group = (PluginGroup)record;
                if (group.getGroupType() == PluginGroup.CELL) {
                    int newFormID = formAdjust.adjustFormID(group.getGroupParentID());
                    FormInfo formInfo = formMap.get(new Integer(newFormID));
                    if (formInfo != null) {
                        pluginGroup = (PluginGroup)((PluginRecord)formInfo.getSource()).getParent();
                        foundGroup = true;
                    }
                }
            } else if (record.getRecordType().equals("CELL")) {
                int newFormID = formAdjust.adjustFormID(record.getFormID());
                FormInfo formInfo = formMap.get(new Integer(newFormID));
                if (formInfo != null) {
                    pluginGroup = (PluginGroup)((PluginRecord)formInfo.getSource()).getParent();
                    foundGroup = true;
                } 
            }

            if (!foundGroup) {
                
                //
                // Create the group hierarchy for the parent group
                //
                PluginGroup grandparentGroup = createHierarchy(parentGroup, formAdjust);

                //
                // Locate the plugin group that corresponds to the parent group.  Note that
                // WORLDSPACE, CELL and TOPIC groups use the parent form ID for the group
                // label and this value will need to be remapped.
                //
                byte[] groupLabel = parentGroup.getGroupLabel();
                int groupParentID = 0;
                switch (groupType) {
                    case PluginGroup.WORLDSPACE:
                    case PluginGroup.CELL:
                    case PluginGroup.CELL_PERSISTENT:
                    case PluginGroup.CELL_TEMPORARY:
                    case PluginGroup.CELL_DISTANT:
                    case PluginGroup.TOPIC:
                        groupParentID = formAdjust.adjustFormID(parentGroup.getGroupParentID());
                }

                List<PluginRecord> recordList = grandparentGroup.getRecordList();
                for (PluginRecord parentRecord : recordList) {
                    if (parentRecord instanceof PluginGroup) {
                        pluginGroup = (PluginGroup)parentRecord;
                        int checkType = pluginGroup.getGroupType();
                        if (checkType == groupType) {
                            if (groupParentID != 0) {
                                if (pluginGroup.getGroupParentID() == groupParentID) {
                                    foundGroup = true;
                                    break;
                                }
                            } else {
                                byte[] checkLabel = pluginGroup.getGroupLabel();
                                if (checkLabel[0] == groupLabel[0] && checkLabel[1] == groupLabel[1] &&
                                                                      checkLabel[2] == groupLabel[2] &&
                                                                      checkLabel[3] == groupLabel[3]) {
                                    foundGroup = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                //
                // Create a new plugin group if necessary.  Note that a Worldspace, Cell or Topic group
                // was created during the recursive call to the createHierarchy() method when it copied
                // the associated WRLD/CELL/DIAL record.
                //
                // The distant cell children subgroup for an exterior cell must appear before the temporary 
                // cell children subgroup.  So we will always insert it at the beginning of the record list.
                //
                // The persistent cell children subgroup for an interior cell must appear before the temporary
                // cell children subgroup.  So we will always insert it at the beginning of the record list.
                //
                if (!foundGroup) {
                    if (groupParentID != 0)
                        pluginGroup = new PluginGroup(groupType, groupParentID);
                    else
                        pluginGroup = new PluginGroup(groupType, groupLabel);
                    
                    pluginGroup.setParent(grandparentGroup);
                    if (groupType == PluginGroup.CELL_DISTANT || groupType == PluginGroup.CELL_PERSISTENT)
                        recordList.add(0, pluginGroup);
                    else
                        recordList.add(pluginGroup);
                    
                    if (Main.debugMode)
                        System.out.printf("%s: Created type %d parent group %08X\n", 
                                          pluginFile.getName(), groupType, groupParentID);
                }
            }
        }

        //
        // A WRLD record is followed by a WORLDSPACE group, a CELL record is followed by a CELL group, 
        // and a DIAL record is followed by a TOPIC group.  We need to copy the WRLD/CELL/DIAL record
        // if we are creating one of these groups.
        //
        if (record instanceof PluginGroup) {
            PluginGroup group = (PluginGroup)record;
            groupType = group.getGroupType();
            if (groupType == PluginGroup.WORLDSPACE || groupType == PluginGroup.CELL || groupType == PluginGroup.TOPIC) {
                int groupParentID = formAdjust.adjustFormID(group.getGroupParentID());
                List<PluginRecord> recordList = parentGroup.getRecordList();
                int recordCount = recordList.size();
                for (int index=1; index<recordCount; index++) {
                    if (recordList.get(index) == group) {
                        PluginRecord prevRecord = recordList.get(index-1);
                        String recordType = prevRecord.getRecordType();
                        if (recordType.equals("WRLD") || recordType.equals("CELL") || recordType.equals("DIAL")) {
                            int formID = prevRecord.getFormID();
                            if (group.getGroupParentID() == formID && formMap.get(new Integer(groupParentID)) == null)
                                copyRecord(prevRecord, formAdjust);
                        }

                        break;
                    }
                }
            }
        }
        
        return pluginGroup;
    }
    
    /**
     * Copy a record from another plugin to this plugin.  The record must be a member of a group
     * in the original plugin.
     *
     * @param       record                  Record being added
     * @param       formAdjust              The form adjustment
     * @exception   DataFormatException     Error while expanding the record data
     * @exception   IOException             An I/O error occurred
     * @exception   PluginException         The record data is not valid
     */
    public void copyRecord(PluginRecord record, FormAdjust formAdjust) 
                                            throws DataFormatException, IOException, PluginException {

        //
        // Create the record hierarchy
        //
        PluginGroup pluginGroup = createHierarchy(record, formAdjust);
        List<PluginRecord> groupRecordList = pluginGroup.getRecordList();

        //
        // Get the new form ID for the record
        //
        int formID = formAdjust.adjustFormID(record.getFormID());
        String editorID = record.getEditorID();
        
        //
        // Add the record to the plugin group
        //
        String recordType = record.getRecordType();
        PluginRecord pluginRecord = (PluginRecord)record.clone();
        pluginRecord.setFormID(formID);
        pluginRecord.setParent(pluginGroup);
        pluginRecord.updateReferences(formAdjust);
        groupRecordList.add(pluginRecord);
        
        //
        // INFO records are sorted based on the PNAM subrecord
        //
        if (recordType.equals("INFO")) {
            
            //
            // Build a mapping from previous form ID to plugin record
            //
            Map<Integer, PluginRecord> prevMap = new HashMap<Integer, PluginRecord>(groupRecordList.size());
            for (PluginRecord checkRecord: groupRecordList) {
                int prevFormID = 0;
                List<PluginSubrecord> subrecords = checkRecord.getSubrecords();
                for (PluginSubrecord subrecord : subrecords) {
                    if (subrecord.getSubrecordType().equals("PNAM")) {
                        prevFormID = getInteger(subrecord.getSubrecordData(), 0);
                        break;
                    }
                }
                
                prevMap.put(new Integer(prevFormID), checkRecord);
            }
            
            //
            // Build the sorted list based on the previous form ID
            //
            List<PluginRecord> sortedList = new ArrayList<PluginRecord>(groupRecordList.size());
            int prevFormID = 0;
            while (true) {
                PluginRecord sortedRecord = prevMap.get(new Integer(prevFormID));
                if (sortedRecord == null)
                    break;
                
                groupRecordList.remove(sortedRecord);
                sortedList.add(sortedRecord);
                prevFormID = sortedRecord.getFormID();
            }

            //
            // Add the sorted records to the group record list.  Any unsorted records
            // will be moved to the end of the record list.
            //
            int count = sortedList.size();
            for (int index=0; index<count; index++)
                groupRecordList.add(index, sortedList.get(index));
        }
        
        //
        // Update the form list and map
        //
        FormInfo formInfo = new FormInfo(pluginRecord, recordType, formID, editorID);
        formInfo.setPlugin(this);
        formInfo.setParentFormID(pluginGroup.getGroupParentID());
        formList.add(formInfo);
        formMap.put(new Integer(formID), formInfo);
        if (Main.debugMode)
            System.out.printf("%s: Added %s record %s (%08X)\n",
                              pluginFile.getName(), recordType, editorID, formID);

        //
        // A WRLD record is followed by a WORLDSPACE group, a CELL record is followed by a CELL group, 
        // and a DIAL record is followed by a TOPIC group.  We need to create the group if we
        // are copying one of these records unless the record is deleted.
        //
        if (!pluginRecord.isDeleted()) {
            PluginGroup subgroup = null;
            if (recordType.equals("WRLD"))
                subgroup = new PluginGroup(PluginGroup.WORLDSPACE, formID);
            else if (recordType.equals("CELL"))
                subgroup = new PluginGroup(PluginGroup.CELL, formID);
            else if (recordType.equals("DIAL"))
                subgroup = new PluginGroup(PluginGroup.TOPIC, formID);
            
            if (subgroup != null) {
                subgroup.setParent(pluginGroup);
                groupRecordList.add(subgroup);
                if (Main.debugMode)
                    System.out.printf("%s: Added type %d group %08X\n",
                                      pluginFile.getName(), subgroup.getGroupType(), formID);
            }
        }
    }
    
    /**
     * Remove a record from the plugin
     *
     * @param       record          The record to remove
     */
    public void removeRecord(PluginRecord record) {
        int formID = record.getFormID();
        String recordType = record.getRecordType();
        PluginGroup parentGroup = (PluginGroup)record.getParent();
        List<PluginRecord> recordList = parentGroup.getRecordList();
        int index = recordList.indexOf(record);
        
        //
        // Remove the record
        //
        if (index >= 0) {
            recordList.remove(index);
            Integer mapFormID = new Integer(formID);
            FormInfo formInfo = formMap.get(mapFormID);
            if (formInfo != null) {
                formMap.remove(mapFormID);
                formList.remove(formInfo);
            }
                            
            //
            // WRLD, CELL and DIAL records are followed by a subgroup, so we need to
            // remove the subgroup as well.  The subgroup will not be removed if it
            // is not empty.
            //
            if (recordType.equals("WRLD") || recordType.equals("CELL") || recordType.equals("DIAL")) {
                if (index < recordList.size()) {
                    PluginRecord checkRecord = recordList.get(index);
                    if (checkRecord instanceof PluginGroup) {
                        PluginGroup subgroup = (PluginGroup)checkRecord;
                        int groupType = subgroup.getGroupType();
                        if (groupType == PluginGroup.WORLDSPACE || groupType == PluginGroup.CELL ||
                                                                   groupType == PluginGroup.TOPIC) {
                            if (subgroup.getGroupParentID() == formID) {
                                subgroup.removeIgnoredRecords();
                                if (subgroup.isEmpty())
                                    recordList.remove(index);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Returns the TOP group for the plugin or null if it doesn't exist
     *
     * @param       groupType          The group record type
     * @return                         The requested group or null
     */
    public PluginGroup getTopGroup(String groupType)
    {
        PluginGroup group = null;

    	List<PluginGroup> topGroups = getGroupList();
        for (PluginGroup topGroup : topGroups)
        {
            String groupRecordType = topGroup.getGroupRecordType();
            if (groupRecordType.equalsIgnoreCase(groupType))
            {
            	group = topGroup;
            	break;
            }
        }
        
        return group;
    }
    
    /**
     * Returns the list of all regions that have the given worldspace form ID
     *
     * @param     WSID                 The WS ID.
     * @return    List<PluginRecord>   The list of region objects (may be empty)
     */
    public List<PluginRecord> getRegionsInWorldspace(int WSID)
    {
    	List<PluginRecord> regionList = new ArrayList<PluginRecord>(); 
    	PluginGroup REGNGroup = getTopGroup("REGN");
		if (REGNGroup == null) return regionList;
		List<PluginRecord> regList = REGNGroup.getRecordList();
		for (PluginRecord region : regList)
		{
			if (region instanceof PluginGroup) continue; // Not interested in cell groups.
			if (!region.getRecordType().equals("REGN")) continue;
			PluginSubrecord regionWS = null;
			try
			{
				regionWS = region.getSubrecord("WNAM");
				if (regionWS == null) continue; // No region assigned.
				String regWSIDstr = regionWS.getDisplayData();
				int regWSID = Integer.parseInt(regWSIDstr, 16);
				if (regWSID == WSID) regionList.add(region);
			}
    		catch (Exception ex)
    		{
    			continue; // Still process.
    		}
		}
		return regionList;
	}

    /**
     * Returns the group of the worldspace that "owns" the given region.
     * Returns null if region not assigned to a WS.
     *
     * @param     region         The region.
     * @return    PluginGroup    The group of the worldspace assigned (may be null)
     */
    public PluginGroup getWorldspaceGroupForRegion(PluginRecord region)
    {
    	PluginGroup WSGroupRegion = null; 
    	int regWSID = -1;
    	if (!region.getRecordType().equals("REGN")) return WSGroupRegion;
		try
		{
			String regWSIDstr = region.getSubrecord("WNAM").getDisplayData();
			// If no region assigned, the null returned will throw also.
			regWSID = Integer.parseInt(regWSIDstr, 16);
		}
		catch (Exception ex)
		{
			return WSGroupRegion; // Not assigned.
		}

    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return WSGroupRegion;
		List<PluginRecord> regList = WRLDGroup.getRecordList();
		for (int i = 0; i < regList.size(); i += 2)
		{
			PluginRecord WSRec = regList.get(i);
			PluginGroup WSGroup = (PluginGroup)regList.get(i + 1);
			if (WSRec.getFormID() == regWSID)
			{
				WSGroupRegion = WSGroup;
				break;
			}
		}
		return WSGroupRegion;
	}

    /**
     * Returns the list of all worldspaces that have the given worldspace form ID as a parent
     *
     * @param     WSID            The WS ID.
     * @return    List<Integer>   The list of worldspace IDs (may be empty)
     */
    public List<PluginRecord> getChildWorldspaces(int WSID)
    {
    	List<PluginRecord> WSList = new ArrayList<PluginRecord>(); 
    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return WSList;
		List<PluginRecord> worldList = WRLDGroup.getRecordList();
		for (PluginRecord world : worldList)
		{
			if (world instanceof PluginGroup) continue; // Not interested in cell groups.
			if (!world.getRecordType().equals("WRLD")) continue;
			PluginSubrecord parentWS = null;
			try
			{
				parentWS = world.getSubrecord("WNAM");
				if (parentWS == null) continue; // No parent WS assigned.
				String worldIDstr = parentWS.getDisplayData();
				int worldID = Integer.parseInt(worldIDstr, 16);
				if (worldID == WSID) WSList.add(world);
			}
    		catch (Exception ex)
    		{
    			continue; // Still process.
    		}
		}
		return WSList;
	}

    /**
     * Returns the list of all regions that have exterior cells in this
     * plugin, not counting the pseudo-CELL where persistent references
     * are stored. This list may be empty or may include the constant
     * Plugin.NoRegionAssignedToCell if there are unassigned exterior cells 
     * in the plugin.
     *
     * @return    List<Integer>   The list of region IDs (may be empty)
     */
    public List<Integer> getCellRegionsUsed()
    {
    	List<Integer> regionList = new ArrayList<Integer>(); 
    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return regionList;
		List<PluginRecord> recList = WRLDGroup.getRecordList();
		for (int i = 0; i < recList.size(); i += 2)
		{
			PluginGroup worldGroup = (PluginGroup)recList.get(i + 1);
			List<PluginRecord> worldGroupList = worldGroup.getRecordList();

			List<PluginGroup> blockList = new ArrayList<PluginGroup>();
			// For this method, we are not using the CELL used for storing persistent refs.
			for (PluginRecord block : worldGroupList)
			{
				if (block instanceof PluginGroup) // No CELL.
				{
					switch(((PluginGroup)block).getGroupType())
					{
					case PluginGroup.CELL: // Persistent references
						break;
					case PluginGroup.EXTERIOR_BLOCK:
						blockList.add((PluginGroup)block);
						break;
					}
				}
			}
			for (PluginGroup block : blockList)
			{
				List<PluginRecord> subBlockList = ((PluginGroup)block).getRecordList(); 
				for (PluginRecord subBlock : subBlockList)
				{
					List<PluginRecord> cellList = ((PluginGroup)subBlock).getRecordList(); 
					for (PluginRecord cell : cellList)
					{
						if (cell instanceof PluginGroup) continue; // Not interested in cell groups.
						if (!cell.getRecordType().equals("CELL")) continue;
						PluginSubrecord region = null;
						try
						{
							region = cell.getSubrecord("XCLR");
						}
			    		catch (Exception ex)
			    		{
			    			; // Still process.
			    		}

						if (region != null)
						{
							String regionIDs = region.getDisplayData();
							String[] regionArray = regionIDs.split(", ");
							for (int j = 0; j < regionArray.length; j++)
							{
								int regionID = Integer.parseInt(regionArray[j], 16);
								if (!regionList.contains(regionID)) regionList.add(regionID);
								
							}
						}
						else // Unassigned to any region
						{
							if (!regionList.contains(Plugin.NoRegionAssignedToCell))
								regionList.add(Plugin.NoRegionAssignedToCell);
						}
							
					}
				}
			}
		}
		return regionList;
	}

    /**
     * Returns the result of getCellRegionsUsed() in string form for debug
     * logging.
     *
     * @param    List<Integer>   The list of region IDs (may be empty)
     * @return   String          Region IDs in hex separated by dashes.
     */
    public String getCellRegionsUsedStr()
    {
    	String retStr = "";
    	List<Integer> regionList = getCellRegionsUsed(); 
		for (Integer i : regionList)
		{
			if (retStr.equals(""))
				retStr = retStr + String.format("%08X", i);
			else
				retStr = retStr + "-" + String.format("%08X", i);
		}			
		return retStr;
	}
    
    /**
     * Goes into all worldspaces and sets the ignore flag on all exterior cells 
     * and associated groups. This does not affect the pseudo-cell where persistent
     * references are stored.
     *
     */
    public void ignoreAllExteriorCells()
    {
    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return;
		List<PluginRecord> recList = WRLDGroup.getRecordList();
		for (int i = 0; i < recList.size(); i += 2)
		{
			PluginGroup worldGroup = (PluginGroup)recList.get(i + 1);
			List<PluginRecord> worldGroupList = worldGroup.getRecordList();

			// For this method, we are not using the CELL used for storing persistent refs.
			for (PluginRecord block : worldGroupList)
			{
				if (block instanceof PluginGroup) // No CELL.
				{
					switch(((PluginGroup)block).getGroupType())
					{
					case PluginGroup.CELL: // Persistent references
						break;
					case PluginGroup.EXTERIOR_BLOCK:
						block.setIgnore(true);
						break;
					}
				}
			}
		}
	}

    /**
     * Goes into all worldspaces and sets the ignore flag on all exterior cells 
     * and associated groups except for cells who have a region ID on the list 
     * given. This does not affect the pseudo-cell where persistent references
     * are stored.
     *
     * @param    List<Integer>   The list of region IDs (may be empty)
     */
    public void ignoreAllExteriorCellsExcept(List<Integer> regionList)
    {
    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return;
		List<PluginRecord> recList = WRLDGroup.getRecordList();
		for (int i = 0; i < recList.size(); i += 2)
		{
			PluginGroup worldGroup = (PluginGroup)recList.get(i + 1);
			List<PluginRecord> worldGroupList = worldGroup.getRecordList();

			List<PluginGroup> blockList = new ArrayList<PluginGroup>();
			// For this method, we are not using the CELL used for storing persistent refs.
			for (PluginRecord block : worldGroupList)
			{
				if (block instanceof PluginGroup) // No CELL.
				{
					switch(((PluginGroup)block).getGroupType())
					{
					case PluginGroup.CELL: // Persistent references
						break;
					case PluginGroup.EXTERIOR_BLOCK:
						blockList.add((PluginGroup)block);
						break;
					}
				}
			}
			for (PluginGroup block : blockList)
			{
				List<PluginRecord> subBlockList = ((PluginGroup)block).getRecordList(); 
				for (PluginRecord subBlock : subBlockList)
				{
					List<PluginRecord> cellList = ((PluginGroup)subBlock).getRecordList(); 
					boolean ignoreCell = false;
					
					for (PluginRecord cell : cellList)
					{
						if (cell instanceof PluginGroup)
						{
							// Check to see if the previous cell (to which this group belongs)
							// set the ignoreCell flag.
							if (ignoreCell) cell.setIgnore(true);
						}
						else // Must be a CELL record.
						{
							// Always reset the ignoreCell flag.
							ignoreCell = false;
							if (!cell.getRecordType().equals("CELL")) continue;
							PluginSubrecord region = null;
							PluginSubrecord XYLoc = null;
							
							try
							{
								XYLoc = cell.getSubrecord("XCLC"); // This should always be there
								region = cell.getSubrecord("XCLR");
							}
				    		catch (Exception ex)
				    		{
			                    if (Main.debugMode && XYLoc != null)
			                    {
			                        System.out.printf("ignoreAllExteriorCellsExcept: Cell (%s) does not have an assigned region\n",
			                        		         XYLoc.getDisplayData());
			                    }
			                    else if (XYLoc == null)
			                    {
			                        System.out.printf("ignoreAllExteriorCellsExcept: Cell %08X does not have XY coordinates\n",
			                        		         cell.getFormID());
			                    }
								ignoreCell = true;
				    		}

							if (region != null)
							{
								String regionIDs = region.getDisplayData();
								String[] regionArray = regionIDs.split(", ");
								// Since we are looking for any match of our region list with 
								// the region list of the cell, assume that the cell will be 
								// excluded and then set to false and break if a match is found.
								ignoreCell = true; // For following group.
								for (int j = 0; j < regionArray.length; j++)
								{
									int regionID = Integer.parseInt(regionArray[j], 16);
									if (regionList.contains(regionID)) // Region list contains regions to NOT ignore.
									{
										ignoreCell = false; // For following group.
										break;
									}
								}
							}
							else
							{
			                    if (Main.debugMode && XYLoc != null)
			                    {
			                        System.out.printf("ignoreAllExteriorCellsExcept: Cell (%s) does not have an assigned region\n",
			                        		         XYLoc.getDisplayData());
			                    }
			                    else if (XYLoc == null)
			                    {
			                        System.out.printf("ignoreAllExteriorCellsExcept: Cell %08X does not have XY coordinates\n",
			                        		         cell.getFormID());
			                    }
								ignoreCell = true;
							}
							if (ignoreCell)
							{
								cell.setIgnore(true);
							}
						}
					}
				}
			}
		}
		return;
	}

    /**
     * Goes into all worldspaces and sets the ignore flag on all exterior cells 
     * and associated groups for the cells who have a region ID on the list 
     * given. This does not affect the pseudo-cell where persistent references
     * are stored. This method will also set ignore on cells without region assignments.
     *
     * @param    List<Integer>   The list of region IDs (may be empty)
     */
    public void ignoreAllExteriorCells(List<Integer> regionList)
    {
    	PluginGroup WRLDGroup = getTopGroup("WRLD");
		if (WRLDGroup == null) return;
		List<PluginRecord> recList = WRLDGroup.getRecordList();
		for (int i = 0; i < recList.size(); i += 2)
		{
			PluginGroup worldGroup = (PluginGroup)recList.get(i + 1);
			List<PluginRecord> worldGroupList = worldGroup.getRecordList();

			List<PluginGroup> blockList = new ArrayList<PluginGroup>();
			// For this method, we are not using the CELL used for storing persistent refs.
			for (PluginRecord block : worldGroupList)
			{
				if (block instanceof PluginGroup) // No CELL.
				{
					switch(((PluginGroup)block).getGroupType())
					{
					case PluginGroup.CELL: // Persistent references
						break;
					case PluginGroup.EXTERIOR_BLOCK:
						blockList.add((PluginGroup)block);
						break;
					}
				}
			}
			for (PluginGroup block : blockList)
			{
				List<PluginRecord> subBlockList = ((PluginGroup)block).getRecordList(); 
				for (PluginRecord subBlock : subBlockList)
				{
					List<PluginRecord> cellList = ((PluginGroup)subBlock).getRecordList(); 
					boolean ignoreCell = false;
					
					for (PluginRecord cell : cellList)
					{
						if (cell instanceof PluginGroup)
						{
							// Check to see if the previous cell (to which this group belongs)
							// set the ignoreCell flag.
							if (ignoreCell) cell.setIgnore(true);
						}
						else // Must be a CELL record.
						{
							// Always reset the ignoreCell flag.
							ignoreCell = false;
							if (!cell.getRecordType().equals("CELL")) continue;
							PluginSubrecord region = null;
							PluginSubrecord XYLoc = null;
							
							try
							{
								XYLoc = cell.getSubrecord("XCLC"); // This should always be there
								region = cell.getSubrecord("XCLR");
							}
				    		catch (Exception ex)
				    		{
			                    if (Main.debugMode && XYLoc != null)
			                    {
			                        System.out.printf("ignoreAllExteriorCells: Cell (%s) does not have an assigned region\n",
			                        		         XYLoc.getDisplayData());
			                    }
			                    else if (XYLoc == null)
			                    {
			                        System.out.printf("ignoreAllExteriorCells: Cell %08X does not have XY coordinates\n",
			                        		         cell.getFormID());
			                    }
								ignoreCell = true;
				    		}

							if (region != null)
							{
								String regionIDs = region.getDisplayData();
								String[] regionArray = regionIDs.split(", ");
								// Since we are looking for any match of our region list with 
								// the region list of the cell, assume that the cell will not be 
								// excluded and then set to true and break if a match is found.
								ignoreCell = false; // For following group.
								for (int j = 0; j < regionArray.length; j++)
								{
									int regionID = Integer.parseInt(regionArray[j], 16);
									if (regionList.contains(regionID)) // Region list contains regions to ignore.
									{
										ignoreCell = true; // For following group.
										break;
									}
								}
							}
							else
							{
			                    if (Main.debugMode && XYLoc != null)
			                    {
			                        System.out.printf("ignoreAllExteriorCells: Cell (%s) does not have an assigned region\n",
			                        		         XYLoc.getDisplayData());
			                    }
			                    else if (XYLoc == null)
			                    {
			                        System.out.printf("ignoreAllExteriorCells: Cell %08X does not have XY coordinates\n",
			                        		         cell.getFormID());
			                    }
								ignoreCell = true;
							}
							if (ignoreCell)
							{
								cell.setIgnore(true);
							}
						}
					}
				}
			}
		}
		return;
	}

    /**
     * Return a string describing the plugin
     *
     * @return                      The plugin name
     */
    public String toString() {
        return pluginFile.getName();
    }
    
    /**
     * Load a plugin file and build the Form ID database.  The record data is stored
     * as-is and will be expanded/parsed as needed.  The FormInfo source will be set
     * to the PluginRecord instance.
     *
     * @param       task                    Worker task or null
     * @exception   DataFormatException     Decompression error occurred
     * @exception   InterruptedException    The worker thread was interrupted
     * @exception   IOException             An I/O error occurred
     * @exception   PluginException         The plugin is not valid
     */
    public void load(WorkerTask task) throws PluginException, DataFormatException, IOException, InterruptedException {
        RandomAccessFile in = null;
        StatusDialog statusDialog = null;
        if (task != null) {
            statusDialog = task.getStatusDialog();
            if (statusDialog != null)
                statusDialog.updateMessage("Loading "+pluginFile.getName());
        }

        try {

            //
            // Open the plugin file
            //
            if (!pluginFile.exists() || !pluginFile.isFile())
                throw new IOException("Plugin file '"+pluginFile.getName()+"' does not exist");
            
            in = new RandomAccessFile(pluginFile, "r");
            
            //
            // Read the plugin header
            //
            pluginHeader.read(in);
            int recordCount = pluginHeader.getRecordCount();
            int processedCount = 0;
            int currentProgress = 0;
            
            //
            // Set form list and map based on record count
            //
            if (recordCount > 1000) {
                formList.ensureCapacity(recordCount);
                formMap = new HashMap<Integer, FormInfo>(recordCount);
            }
            
            //
            // Process the top-level plugin groups
            //
            // Bytes 00-03: 'GRUP'
            // Bytes 04-07: Record length including the 20-byte prefix
            // Bytes 08-11: Group label (null-terminated string for a top-level group)
            // Bytes 12-15: Group type (0 indicates a top-level group)
            // Bytes 16-19: <unknown>
            //
            byte[] prefix = new byte[20];
            int count, length;
            int loadCount = 0;
            String type;
            
            while (true) {
                
                //
                // Read the group prefix
                //
                count = in.read(prefix);
                if (count == -1)
                    break;
                
                if (count != 20)
                    throw new PluginException(pluginFile.getName()+": Group record prefix is too short");
        
                type = new String(prefix, 0, 4);
                if (!type.equals("GRUP"))
                    throw new PluginException(pluginFile.getName()+": Top-level record is not a group");
                
                if (prefix[12] != 0)
                    throw new PluginException(pluginFile.getName()+": Top-level group type is not 0");
                
                length = getInteger(prefix, 4);
                length -= 20;

                //
                // Load the group
                //
                PluginGroup group = new PluginGroup(prefix);
                if (Main.debugMode)
                    System.out.printf("%s: Loading group %s\n", pluginFile.getName(), group.getGroupRecordType());
                
                group.load(pluginFile, in, length);
                group.updateFormList(formList);
                groupList.add(group);
                loadCount += group.getRecordCount()+1;
                
                //
                // Stop now if the user has canceled the request
                //
                if (task != null && task.interrupted())
                    throw new InterruptedException("Request canceled");
                
                //
                // Update the progress bar
                //
                processedCount++;
                int newProgress = Math.min((processedCount*100)/initialGroupList.length, 100);
                if (statusDialog != null && newProgress >= currentProgress+5) {
                    currentProgress = newProgress;
                    statusDialog.updateProgress(currentProgress);
                }
            }

            if (loadCount != recordCount) {
                String text = pluginFile.getName()+": Load count "+loadCount+" does not match header count "+recordCount;
                int selection = WorkerDialog.showConfirmDialog(task.getParent(),  
                                                text+". Do you want to continue?",
                                                "Error", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE, false);
                if (selection != WorkerDialog.YES_OPTION)
                    throw new PluginException(text);
            }
            
            //
            // Build the Form ID mappings
            //
            for (FormInfo info : formList) {
                info.setPlugin(this);
                formMap.put(new Integer(info.getFormID()),  info);
            }
            
            //
            // The Oblivion master file has references to REFR 'PlayerREF' but it never defines
            // the reference.  So we will create a dummy mapping to allow merging objects
            // obtained from the Oblivion master file.  The NPC_ 'Player' has Form ID 7 in
            // this case.
            //
            if (pluginHeader.getMasterList().size() == 0) {
                Integer refFormID = new Integer(20);
                if (formMap.get(refFormID) == null) {
                    FormInfo playerInfo = formMap.get(new Integer(7));
                    if (playerInfo != null && playerInfo.getRecordType().equals("NPC_") && 
                                              playerInfo.getEditorID().equals("Player")) {
                        FormInfo playerRefInfo = new FormInfo(null, "REFR",  20,  "PlayerREF");
                        formList.add(playerRefInfo);
                        formMap.put(refFormID, playerRefInfo);
                    }
                }
            }
        } finally {
            if (in != null)
                in.close();
        }
    }
    
    /**
     * Write the plugin to the plugin file
     *
     * @param       task                    Worker task or null
     * @exception   DataFormatException     Compression error occurred
     * @exception   InterruptedException    The worker thread was interrupted
     * @exception   IOException             An I/O error occurred
     */
    public void store(WorkerTask task) throws DataFormatException, IOException, InterruptedException {
        File outFile = null;
        RandomAccessFile out = null;
        boolean groupsWritten = false;
        StatusDialog statusDialog = null;
        if (task != null) {
            statusDialog = task.getStatusDialog();
            if (statusDialog != null)
                statusDialog.updateMessage("Saving "+pluginFile.getName());
        }
    
        //
        // Set the record count for the plugin.  Ignored records will not be saved in the
        // rewritten plugin.
        //
        int recordCount = 0;
        for (PluginGroup group : groupList) {
            group.removeIgnoredRecords();
            int count = group.getRecordCount();
            if (count != 0)
                recordCount += count+1;
        }
        
        pluginHeader.setRecordCount(recordCount);
        
        try {
            
            //
            // Open the output file
            //
            outFile = new File(pluginFile.getParent()+Main.fileSeparator+"Gecko.tmp");
            if (outFile.exists())
                outFile.delete();
            
            out = new RandomAccessFile(outFile, "rw");
        
            //
            // Write the plugin header
            //
            pluginHeader.write(out);
            int groupCount = groupList.size();
            int processedCount = 0;
            int currentProgress = 0;
            
            //
            // Write the groups.  Groups containing no records will not be written.
            //
            for (PluginGroup group : groupList) {
                if (!group.isEmpty())
                    group.store(out);
                
                if (task != null && task.interrupted())
                    throw new InterruptedException("Request canceled");
                
                processedCount++;
                int newProgress = (processedCount*100)/groupCount;
                if (statusDialog != null && newProgress >= currentProgress+5) {
                    currentProgress = newProgress;
                    statusDialog.updateProgress(currentProgress);
                }
            }
            
            groupsWritten = true;
        } finally {
            if (out != null)
                out.close();
            
            if (outFile.exists()) {
                if (groupsWritten) {
                    if (pluginFile.exists())
                        pluginFile.delete();
                    
                    outFile.renameTo(pluginFile);
                } else {
                    outFile.delete();
                }
            }
        }
    }
}
